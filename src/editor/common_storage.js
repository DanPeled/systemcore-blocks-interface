/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @author lizlooney@google.com (Liz Looney)
 */

// Functions related to files, regardless of where the files are stored.

/**
 * Make the file content from the given python code and blocks content.
 */
function makeFileContent(pythonCode, blocksForExports, blocksContent) {
  let delimiter = 'BlocksContent';
  while (blocksContent.includes(delimiter) || blocksForExports.includes(delimiter)) {
    delimiter += '.';
  }
  return (
      '# This file was generated by the Blocks editor.\n\n' +
      pythonCode + '\n\n\n' +
      '"""\n' +
      delimiter + '\n' +
      blocksForExports + '\n' +
      delimiter + '\n' +
      blocksContent + '\n' +
      delimiter + '\n' +
      '"""\n');
}

/**
 * Extract the blocks content from the given file content.
 */
function extractBlocksContent(fileContent) {
  // The last line is """.
  const lastChars = '\n"""\n';
  if (!fileContent.endsWith(lastChars) || fileContent.length <= lastChars.length) {
    throw 'Unable to extract the blocks content.';
  }
  // The line before that is the delimiter.
  const iEndOfDelimiter = fileContent.length - lastChars.length;
  const iPreviousNewLine = fileContent.lastIndexOf('\n', iEndOfDelimiter - 1);
  if (iPreviousNewLine == -1) {
    throw 'Unable to extract the blocks content.';
  }
  const iEndOfBlocksContent = iPreviousNewLine;
  const iStartOfDelimiter = iPreviousNewLine + 1;
  const delimiter = fileContent.substring(iStartOfDelimiter, iEndOfDelimiter);
  // Now, find the previous delimiter.
  const iStartOfPreviousDelimiter = fileContent.lastIndexOf(delimiter, iPreviousNewLine - 1);
  if (iStartOfPreviousDelimiter == -1) {
    throw 'Unable to extract the blocks content.';
  }
  // The blocks content is between the two delimiters.
  const iStartOfBlocksContent = iStartOfPreviousDelimiter + delimiter.length + 1;
  return fileContent.substring(iStartOfBlocksContent, iEndOfBlocksContent);
}

/**
 * Extract the blocksForExports from the given file content.
 */
function extractBlocksForExports(fileContent) {
  // The last line is """.
  const lastChars = '\n"""\n';
  if (!fileContent.endsWith(lastChars) || fileContent.length <= lastChars.length) {
    throw 'Unable to extract the blocksForExports.';
  }
  // The line before that is the delimiter.
  const iEndOfDelimiter = fileContent.length - lastChars.length;
  const iPreviousNewLine = fileContent.lastIndexOf('\n', iEndOfDelimiter - 1);
  if (iPreviousNewLine == -1) {
    throw 'Unable to extract the blocksForExports.';
  }
  const iStartOfDelimiter = iPreviousNewLine + 1;
  const delimiter = fileContent.substring(iStartOfDelimiter, iEndOfDelimiter);
  // Now, find the previous delimiter.
  let iStartOfPreviousDelimiter = fileContent.lastIndexOf(delimiter, iPreviousNewLine - 1);
  if (iStartOfPreviousDelimiter == -1) {
    throw 'Unable to extract the blocksForExports.';
  }
  const iEndOfBlocksForExports = iStartOfPreviousDelimiter - 1;
  // Now, find the previous delimiter before that.
  iStartOfPreviousDelimiter = fileContent.lastIndexOf(delimiter, iStartOfPreviousDelimiter - 1);
  if (iStartOfPreviousDelimiter == -1) {
    throw 'Unable to extract the blocksForExports.';
  }
  // The blocksForExports content is between the two delimiters.
  const iStartOfBlocksForExports = iStartOfPreviousDelimiter + delimiter.length + 1;
  return fileContent.substring(iStartOfBlocksForExports, iEndOfBlocksForExports);
}

export {
  makeFileContent,
  extractBlocksContent,
  extractBlocksForExports,
}
