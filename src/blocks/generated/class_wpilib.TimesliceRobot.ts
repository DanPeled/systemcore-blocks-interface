// This file was generated. Do not edit!

import * as python from "../python";
import {Category} from "../../toolbox/items";

// Blocks for class wpilib.TimesliceRobot

export function initialize() {
  python.initializeClassVariableGetter("wpilib.TimesliceRobot", "float", ["kDefaultPeriod"], []);
}

export function getToolboxCategory(subcategories: any): Category {
  const category = {
    kind: "category",
    name: "TimesliceRobot",
    contents: [
      {"kind": "block", "type": "get_python_class_variable", "extraState": {"varType": "float", "key": "class wpilib.TimesliceRobot float", "importModule": "wpilib"}, "fields": {"CLASS": "wpilib.TimesliceRobot", "VAR": "kDefaultPeriod"}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTimesliceRobot"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "call_python_constructor", "extraState": {"tooltip": "Constructor for TimesliceRobot.\n\n:param robotPeriodicAllocation: The allocation to give the TimesliceRobot\n                                periodic functions.\n:param controllerPeriod:        The controller period. The sum of all scheduler\n                                allocations should be less than or equal to this\n                                value.", "returnType": "wpilib._wpilib.TimesliceRobot", "args": [{"name": "robotPeriodicAllocation", "type": "wpimath.units.seconds"}, {"name": "controllerPeriod", "type": "wpimath.units.seconds"}], "importModule": "wpilib"}, "fields": {"CLASS": "wpilib.TimesliceRobot"}}}}},
      {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "Add a callback to run at a specific period with a starting time offset.\n\nThis is scheduled on TimedRobot's Notifier, so TimedRobot and the callback\nrun synchronously. Interactions between them are thread-safe.\n\n:param callback: The callback to run.\n:param period:   The period at which to run the callback.\n:param offset:   The offset from the common starting time. This is useful\n                 for scheduling a callback in a different timeslot relative\n                 to TimedRobot.", "returnType": "None", "args": [{"name": "timedRobot", "type": "wpilib._wpilib.TimedRobot"}, {"name": "callback", "type": "Callable[[], None]"}, {"name": "period", "type": "wpimath.units.seconds"}, {"name": "offset", "type": "wpimath.units.seconds"}], "importModule": ""}, "fields": {"CLASS": "wpilib.TimedRobot", "FUNC": "addPeriodic"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myTimedRobot"}}}}}},
      {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "Exit code for autonomous mode should go here.\n\nUsers should override this method for code which will be called each time\nthe robot exits autonomous mode.", "returnType": "None", "args": [{"name": "iterativeRobotBase", "type": "wpilib._wpilib.IterativeRobotBase"}], "importModule": ""}, "fields": {"CLASS": "wpilib.IterativeRobotBase", "FUNC": "autonomousExit"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myIterativeRobotBase"}}}}}},
      {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "Initialization code for autonomous mode should go here.\n\nUsers should override this method for initialization code which will be\ncalled each time the robot enters autonomous mode.", "returnType": "None", "args": [{"name": "iterativeRobotBase", "type": "wpilib._wpilib.IterativeRobotBase"}], "importModule": ""}, "fields": {"CLASS": "wpilib.IterativeRobotBase", "FUNC": "autonomousInit"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myIterativeRobotBase"}}}}}},
      {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "Periodic code for autonomous mode should go here.\n\nUsers should override this method for code which will be called each time a\nnew packet is received from the driver station and the robot is in\nautonomous mode.", "returnType": "None", "args": [{"name": "iterativeRobotBase", "type": "wpilib._wpilib.IterativeRobotBase"}], "importModule": ""}, "fields": {"CLASS": "wpilib.IterativeRobotBase", "FUNC": "autonomousPeriodic"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myIterativeRobotBase"}}}}}},
      {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "Exit code for disabled mode should go here.\n\nUsers should override this method for code which will be called each time\nthe robot exits disabled mode.", "returnType": "None", "args": [{"name": "iterativeRobotBase", "type": "wpilib._wpilib.IterativeRobotBase"}], "importModule": ""}, "fields": {"CLASS": "wpilib.IterativeRobotBase", "FUNC": "disabledExit"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myIterativeRobotBase"}}}}}},
      {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "Initialization code for disabled mode should go here.\n\nUsers should override this method for initialization code which will be\ncalled each time\nthe robot enters disabled mode.", "returnType": "None", "args": [{"name": "iterativeRobotBase", "type": "wpilib._wpilib.IterativeRobotBase"}], "importModule": ""}, "fields": {"CLASS": "wpilib.IterativeRobotBase", "FUNC": "disabledInit"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myIterativeRobotBase"}}}}}},
      {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "Periodic code for disabled mode should go here.\n\nUsers should override this method for code which will be called each time a\nnew packet is received from the driver station and the robot is in disabled\nmode.", "returnType": "None", "args": [{"name": "iterativeRobotBase", "type": "wpilib._wpilib.IterativeRobotBase"}], "importModule": ""}, "fields": {"CLASS": "wpilib.IterativeRobotBase", "FUNC": "disabledPeriodic"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myIterativeRobotBase"}}}}}},
      {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "Code that needs to know the DS state should go here.\n\nUsers should override this method for initialization that needs to occur\nafter the DS is connected, such as needing the alliance information.", "returnType": "None", "args": [{"name": "iterativeRobotBase", "type": "wpilib._wpilib.IterativeRobotBase"}], "importModule": ""}, "fields": {"CLASS": "wpilib.IterativeRobotBase", "FUNC": "driverStationConnected"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myIterativeRobotBase"}}}}}},
      {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "Sets whether LiveWindow operation is enabled during test mode.\n\n:param testLW: True to enable, false to disable. Defaults to false.\n               @throws if called in test mode.", "returnType": "None", "args": [{"name": "iterativeRobotBase", "type": "wpilib._wpilib.IterativeRobotBase"}, {"name": "testLW", "type": "bool"}], "importModule": ""}, "fields": {"CLASS": "wpilib.IterativeRobotBase", "FUNC": "enableLiveWindowInTest"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myIterativeRobotBase"}}}}}},
      {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "Ends the main loop in StartCompetition().", "returnType": "None", "args": [{"name": "timedRobot", "type": "wpilib._wpilib.TimedRobot"}], "importModule": ""}, "fields": {"CLASS": "wpilib.TimedRobot", "FUNC": "endCompetition"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myTimedRobot"}}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "More efficient way to determine what state the robot is in.\n\n:returns: booleans representing enabled, isautonomous, istest\n\n.. versionadded:: 2019.2.1\n\n.. note:: This function only exists in RobotPy", "returnType": "tuple[bool, bool, bool]", "args": [{"name": "robotBase", "type": "wpilib._wpilib.RobotBase"}], "importModule": ""}, "fields": {"CLASS": "wpilib.RobotBase", "FUNC": "getControlState"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myRobotBase"}}}}}}}}},
      {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "Gets time period between calls to Periodic() functions.", "returnType": "wpimath.units.seconds", "args": [{"name": "iterativeRobotBase", "type": "wpilib._wpilib.IterativeRobotBase"}], "importModule": ""}, "fields": {"CLASS": "wpilib.IterativeRobotBase", "FUNC": "getPeriod"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myIterativeRobotBase"}}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myRuntimeType"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "call_python_static_method", "extraState": {"tooltip": "Get the current runtime type.\n\n:returns: Current runtime type.", "returnType": "wpilib._wpilib.RuntimeType", "args": [], "importModule": "wpilib"}, "fields": {"CLASS": "wpilib.TimesliceRobot", "FUNC": "getRuntimeType"}}}}},
      {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "Determine if the robot is currently in Autonomous mode.\n\n:returns: True if the robot is currently operating Autonomously as determined\n          by the Driver Station.", "returnType": "bool", "args": [{"name": "robotBase", "type": "wpilib._wpilib.RobotBase"}], "importModule": ""}, "fields": {"CLASS": "wpilib.RobotBase", "FUNC": "isAutonomous"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myRobotBase"}}}}}},
      {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "Determine if the robot is currently in Autonomous mode and enabled.\n\n:returns: True if the robot us currently operating Autonomously while enabled\n          as determined by the Driver Station.", "returnType": "bool", "args": [{"name": "robotBase", "type": "wpilib._wpilib.RobotBase"}], "importModule": ""}, "fields": {"CLASS": "wpilib.RobotBase", "FUNC": "isAutonomousEnabled"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myRobotBase"}}}}}},
      {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "Determine if the Robot is currently disabled.\n\n:returns: True if the Robot is currently disabled by the Driver Station.", "returnType": "bool", "args": [{"name": "robotBase", "type": "wpilib._wpilib.RobotBase"}], "importModule": ""}, "fields": {"CLASS": "wpilib.RobotBase", "FUNC": "isDisabled"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myRobotBase"}}}}}},
      {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "Determine if the Robot is currently enabled.\n\n:returns: True if the Robot is currently enabled by the Driver Station.", "returnType": "bool", "args": [{"name": "robotBase", "type": "wpilib._wpilib.RobotBase"}], "importModule": ""}, "fields": {"CLASS": "wpilib.RobotBase", "FUNC": "isEnabled"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myRobotBase"}}}}}},
      {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "Whether LiveWindow operation is enabled during test mode.", "returnType": "bool", "args": [{"name": "iterativeRobotBase", "type": "wpilib._wpilib.IterativeRobotBase"}], "importModule": ""}, "fields": {"CLASS": "wpilib.IterativeRobotBase", "FUNC": "isLiveWindowEnabledInTest"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myIterativeRobotBase"}}}}}},
      {"kind": "block", "type": "call_python_static_method", "extraState": {"tooltip": "Get if the robot is real.\n\n:returns: If the robot is running in the real world.", "returnType": "bool", "args": [], "importModule": "wpilib"}, "fields": {"CLASS": "wpilib.TimesliceRobot", "FUNC": "isReal"}},
      {"kind": "block", "type": "call_python_static_method", "extraState": {"tooltip": "Get if the robot is a simulation.\n\n:returns: If the robot is running in simulation.", "returnType": "bool", "args": [], "importModule": "wpilib"}, "fields": {"CLASS": "wpilib.TimesliceRobot", "FUNC": "isSimulation"}},
      {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "Determine if the robot is currently in Operator Control mode.\n\n:returns: True if the robot is currently operating in Tele-Op mode as\n          determined by the Driver Station.", "returnType": "bool", "args": [{"name": "robotBase", "type": "wpilib._wpilib.RobotBase"}], "importModule": ""}, "fields": {"CLASS": "wpilib.RobotBase", "FUNC": "isTeleop"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myRobotBase"}}}}}},
      {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "Determine if the robot is current in Operator Control mode and enabled.\n\n:returns: True if the robot is currently operating in Tele-Op mode while\n          enabled as determined by the Driver Station.", "returnType": "bool", "args": [{"name": "robotBase", "type": "wpilib._wpilib.RobotBase"}], "importModule": ""}, "fields": {"CLASS": "wpilib.RobotBase", "FUNC": "isTeleopEnabled"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myRobotBase"}}}}}},
      {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "Determine if the robot is currently in Test mode.\n\n:returns: True if the robot is currently running in Test mode as determined\n          by the Driver Station.", "returnType": "bool", "args": [{"name": "robotBase", "type": "wpilib._wpilib.RobotBase"}], "importModule": ""}, "fields": {"CLASS": "wpilib.RobotBase", "FUNC": "isTest"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myRobotBase"}}}}}},
      {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "Determine if the robot is current in Test mode and enabled.\n\n:returns: True if the robot is currently operating in Test mode while\n          enabled as determined by the Driver Station.", "returnType": "bool", "args": [{"name": "robotBase", "type": "wpilib._wpilib.RobotBase"}], "importModule": ""}, "fields": {"CLASS": "wpilib.RobotBase", "FUNC": "isTestEnabled"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myRobotBase"}}}}}},
      {"kind": "block", "type": "call_python_static_method", "extraState": {"tooltip": "Starting point for the application", "returnType": "object", "args": [{"name": "robot_cls", "type": "object"}], "importModule": "wpilib"}, "fields": {"CLASS": "wpilib.TimesliceRobot", "FUNC": "main"}},
      {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "Robot-wide initialization code should go here.\n\nUsers should override this method for default Robot-wide initialization\nwhich will be called when the robot is first powered on. It will be called\nexactly one time.\n\nWarning: the Driver Station \"Robot Code\" light and FMS \"Robot Ready\"\nindicators will be off until RobotInit() exits. Code in RobotInit() that\nwaits for enable will cause the robot to never indicate that the code is\nready, causing the robot to be bypassed in a match.", "returnType": "None", "args": [{"name": "iterativeRobotBase", "type": "wpilib._wpilib.IterativeRobotBase"}], "importModule": ""}, "fields": {"CLASS": "wpilib.IterativeRobotBase", "FUNC": "robotInit"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myIterativeRobotBase"}}}}}},
      {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "Periodic code for all modes should go here.\n\nThis function is called each time a new packet is received from the driver\nstation.", "returnType": "None", "args": [{"name": "iterativeRobotBase", "type": "wpilib._wpilib.IterativeRobotBase"}], "importModule": ""}, "fields": {"CLASS": "wpilib.IterativeRobotBase", "FUNC": "robotPeriodic"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myIterativeRobotBase"}}}}}},
      {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "Schedule a periodic function with the constructor's controller period and\nthe given allocation. The function's runtime allocation will be placed\nafter the end of the previous one's.\n\nIf a call to this function makes the allocations exceed the controller\nperiod, an exception will be thrown since that means the TimesliceRobot\nperiodic functions and the given function will have conflicting\ntimeslices.\n\n:param func:       Function to schedule.\n:param allocation: The function's runtime allocation out of the controller\n                   period.", "returnType": "None", "args": [{"name": "timesliceRobot", "type": "wpilib._wpilib.TimesliceRobot"}, {"name": "func", "type": "Callable[[], None]"}, {"name": "allocation", "type": "wpimath.units.seconds"}], "importModule": ""}, "fields": {"CLASS": "wpilib.TimesliceRobot", "FUNC": "schedule"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myTimesliceRobot"}}}}}},
      {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "Enables or disables flushing NetworkTables every loop iteration.\nBy default, this is enabled.\n\n:param enabled: True to enable, false to disable", "returnType": "None", "args": [{"name": "iterativeRobotBase", "type": "wpilib._wpilib.IterativeRobotBase"}, {"name": "enabled", "type": "bool"}], "importModule": ""}, "fields": {"CLASS": "wpilib.IterativeRobotBase", "FUNC": "setNetworkTablesFlushEnabled"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myIterativeRobotBase"}}}}}},
      {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "Provide an alternate \"main loop\" via StartCompetition().", "returnType": "None", "args": [{"name": "timedRobot", "type": "wpilib._wpilib.TimedRobot"}], "importModule": ""}, "fields": {"CLASS": "wpilib.TimedRobot", "FUNC": "startCompetition"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myTimedRobot"}}}}}},
      {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "Exit code for teleop mode should go here.\n\nUsers should override this method for code which will be called each time\nthe robot exits teleop mode.", "returnType": "None", "args": [{"name": "iterativeRobotBase", "type": "wpilib._wpilib.IterativeRobotBase"}], "importModule": ""}, "fields": {"CLASS": "wpilib.IterativeRobotBase", "FUNC": "teleopExit"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myIterativeRobotBase"}}}}}},
      {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "Initialization code for teleop mode should go here.\n\nUsers should override this method for initialization code which will be\ncalled each time the robot enters teleop mode.", "returnType": "None", "args": [{"name": "iterativeRobotBase", "type": "wpilib._wpilib.IterativeRobotBase"}], "importModule": ""}, "fields": {"CLASS": "wpilib.IterativeRobotBase", "FUNC": "teleopInit"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myIterativeRobotBase"}}}}}},
      {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "Periodic code for teleop mode should go here.\n\nUsers should override this method for code which will be called each time a\nnew packet is received from the driver station and the robot is in teleop\nmode.", "returnType": "None", "args": [{"name": "iterativeRobotBase", "type": "wpilib._wpilib.IterativeRobotBase"}], "importModule": ""}, "fields": {"CLASS": "wpilib.IterativeRobotBase", "FUNC": "teleopPeriodic"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myIterativeRobotBase"}}}}}},
      {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "Exit code for test mode should go here.\n\nUsers should override this method for code which will be called each time\nthe robot exits test mode.", "returnType": "None", "args": [{"name": "iterativeRobotBase", "type": "wpilib._wpilib.IterativeRobotBase"}], "importModule": ""}, "fields": {"CLASS": "wpilib.IterativeRobotBase", "FUNC": "testExit"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myIterativeRobotBase"}}}}}},
      {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "Initialization code for test mode should go here.\n\nUsers should override this method for initialization code which will be\ncalled each time the robot enters test mode.", "returnType": "None", "args": [{"name": "iterativeRobotBase", "type": "wpilib._wpilib.IterativeRobotBase"}], "importModule": ""}, "fields": {"CLASS": "wpilib.IterativeRobotBase", "FUNC": "testInit"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myIterativeRobotBase"}}}}}},
      {"kind": "block", "type": "call_python_instance_method", "extraState": {"tooltip": "Periodic code for test mode should go here.\n\nUsers should override this method for code which will be called each time a\nnew packet is received from the driver station and the robot is in test\nmode.", "returnType": "None", "args": [{"name": "iterativeRobotBase", "type": "wpilib._wpilib.IterativeRobotBase"}], "importModule": ""}, "fields": {"CLASS": "wpilib.IterativeRobotBase", "FUNC": "testPeriodic"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myIterativeRobotBase"}}}}}},
    ],
  };
  if (subcategories) {
    category.contents.push(...subcategories);
  }
  return category;
}
