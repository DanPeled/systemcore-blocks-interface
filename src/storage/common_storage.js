/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @author lizlooney@google.com (Liz Looney)
 */

// Functions related to files, regardless of where the files are stored.

export const MODULE_TYPE_WORKSPACE = 'workspace';
export const MODULE_TYPE_OPMODE = 'opmode';

/**
 * Returns true if the given name is a valid python module name.
 */
export function isValidPythonModuleName(name) {
  if (name) {
    return /^[a-z_][a-z0-9_]*$/.test(name);
  }
  return false;
}

/**
 * Returns the module file path for the given workspace and module names.
 */
export function makeModuleFilePath(workspaceName, moduleName) {
  return workspaceName + '/' + moduleName + '.py';
}

/**
 * Returns the workspace name for given module file path.
 */
export function getWorkspaceName(moduleFilePath) {
  const regex = new RegExp('^([a-z_][a-z0-9_]*)/([a-z_][a-z0-9_]*).py$');
  const result = regex.exec(moduleFilePath)
  if (!result) {
    throw new Error('Unable to extract the workspace name.');
  }
  return result[1];
}

/**
 * Returns the module name for given module file path.
 */
export function getModuleName(moduleFilePath) {
  const regex = new RegExp('^([a-z_][a-z0-9_]*)/([a-z_][a-z0-9_]*).py$');
  const result = regex.exec(moduleFilePath)
  if (!result) {
    throw new Error('Unable to extract the module name.');
  }
  return result[2];
}

/**
 * Returns the download file name for the given module file path.
 */
export function makeDownloadFileName(moduleFilePath) {
  return getWorkspaceName(moduleFilePath) + '-' + getModuleName(moduleFilePath) + '.wpilib_blocks';
}

export function makeUploadWorkspaceName(uploadFileName) {
  // Check if the name is <workspace name>-<workspace name>.
  const regex = new RegExp('^([a-z_][a-z0-9_]*)-([a-z_][a-z0-9_]*).wpilib_blocks$');
  const result = regex.exec(uploadFileName);
  if (!result || result[1] !== result[2]) {
    throw new Error(uploadFileName + ' is not a valid file name for uploading as a workspace');
  }
  return result[2];
}

/**
 * Returns the file content for a new module.
 */
export function newModuleFileContent() {
  const pythonCode = '\n';
  const blocksForExports = '[]';
  const blocksContent = '{}';
  return makeFileContent(pythonCode, blocksForExports, blocksContent);
}

/**
 * Make the file content from the given python code and blocks content.
 */
export function makeFileContent(pythonCode, blocksForExports, blocksContent) {
  let delimiter = 'BlocksContent';
  while (blocksContent.includes(delimiter) || blocksForExports.includes(delimiter)) {
    delimiter += '.';
  }
  return (
      '# This file was generated by the Blocks editor.\n\n' +
      pythonCode + '\n\n\n' +
      '"""\n' +
      delimiter + '\n' +
      blocksForExports + '\n' +
      delimiter + '\n' +
      blocksContent + '\n' +
      delimiter + '\n' +
      '"""\n');
}

/**
 * Extract the blocks content from the given file content.
 */
export function extractBlocksContent(fileContent) {
  // The last line is """.
  const lastChars = '\n"""\n';
  if (!fileContent.endsWith(lastChars) || fileContent.length <= lastChars.length) {
    throw new Error('Unable to extract the blocks content.');
  }
  // The line before that is the delimiter.
  const iEndOfDelimiter = fileContent.length - lastChars.length;
  const iPreviousNewLine = fileContent.lastIndexOf('\n', iEndOfDelimiter - 1);
  if (iPreviousNewLine === -1) {
    throw new Error('Unable to extract the blocks content.');
  }
  const iEndOfBlocksContent = iPreviousNewLine;
  const iStartOfDelimiter = iPreviousNewLine + 1;
  const delimiter = fileContent.substring(iStartOfDelimiter, iEndOfDelimiter);
  // Now, find the previous delimiter.
  const iStartOfPreviousDelimiter = fileContent.lastIndexOf(delimiter, iPreviousNewLine - 1);
  if (iStartOfPreviousDelimiter === -1) {
    throw new Error('Unable to extract the blocks content.');
  }
  // The blocks content is between the two delimiters.
  const iStartOfBlocksContent = iStartOfPreviousDelimiter + delimiter.length + 1;
  return fileContent.substring(iStartOfBlocksContent, iEndOfBlocksContent);
}

/**
 * Extract the blocksForExports from the given file content.
 */
export function extractBlocksForExports(fileContent) {
  // The last line is """.
  const lastChars = '\n"""\n';
  if (!fileContent.endsWith(lastChars) || fileContent.length <= lastChars.length) {
    throw new Error('Unable to extract the blocksForExports.');
  }
  // The line before that is the delimiter.
  const iEndOfDelimiter = fileContent.length - lastChars.length;
  const iPreviousNewLine = fileContent.lastIndexOf('\n', iEndOfDelimiter - 1);
  if (iPreviousNewLine === -1) {
    throw new Error('Unable to extract the blocksForExports.');
  }
  const iStartOfDelimiter = iPreviousNewLine + 1;
  const delimiter = fileContent.substring(iStartOfDelimiter, iEndOfDelimiter);
  // Now, find the previous delimiter.
  let iStartOfPreviousDelimiter = fileContent.lastIndexOf(delimiter, iPreviousNewLine - 1);
  if (iStartOfPreviousDelimiter === -1) {
    throw new Error('Unable to extract the blocksForExports.');
  }
  const iEndOfBlocksForExports = iStartOfPreviousDelimiter - 1;
  // Now, find the previous delimiter before that.
  iStartOfPreviousDelimiter = fileContent.lastIndexOf(delimiter, iStartOfPreviousDelimiter - 1);
  if (iStartOfPreviousDelimiter === -1) {
    throw new Error('Unable to extract the blocksForExports.');
  }
  // The blocksForExports content is between the two delimiters.
  const iStartOfBlocksForExports = iStartOfPreviousDelimiter + delimiter.length + 1;
  return fileContent.substring(iStartOfBlocksForExports, iEndOfBlocksForExports);
}
