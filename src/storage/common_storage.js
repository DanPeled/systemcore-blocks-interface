/**
 * @license
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @author lizlooney@google.com (Liz Looney)
 */

// Functions related to files, regardless of where the files are stored.

export const MODULE_TYPE_WORKSPACE = 'workspace';
export const MODULE_TYPE_OPMODE = 'opmode';

export const MODULE_NAME_PLACEHOLDER = '%module_name%';

/**
 * Returns true if the given name is a valid python module name.
 */
export function isValidPythonModuleName(name) {
  if (name) {
    return /^[a-z_][a-z0-9_]*$/.test(name);
  }
  return false;
}

/**
 * Returns the module file path for the given workspace and module names.
 */
export function makeModuleFilePath(workspaceName, moduleName) {
  return workspaceName + '/' + moduleName + '.py';
}

/**
 * Returns the workspace name for given module file path.
 */
export function getWorkspaceName(moduleFilePath) {
  const regex = new RegExp('^([a-z_][a-z0-9_]*)/([a-z_][a-z0-9_]*).py$');
  const result = regex.exec(moduleFilePath)
  if (!result) {
    throw new Error('Unable to extract the workspace name.');
  }
  return result[1];
}

/**
 * Returns the module name for given module file path.
 */
export function getModuleName(moduleFilePath) {
  const regex = new RegExp('^([a-z_][a-z0-9_]*)/([a-z_][a-z0-9_]*).py$');
  const result = regex.exec(moduleFilePath)
  if (!result) {
    throw new Error('Unable to extract the module name.');
  }
  return result[2];
}

/**
 * Returns the download file name for the given module file path.
 */
export function makeDownloadFileName(moduleFilePath) {
  return getWorkspaceName(moduleFilePath) + '-' + getModuleName(moduleFilePath) + '.wpilib_blocks';
}

export function makeUploadWorkspaceName(uploadFileName) {
  // Check if the name is <workspace name>-<workspace name>.
  const regex = new RegExp('^([a-z_][a-z0-9_]*)-([a-z_][a-z0-9_]*).wpilib_blocks$');
  const result = regex.exec(uploadFileName);
  if (!result || result[1] !== result[2]) {
    throw new Error(uploadFileName + ' is not a valid file name for uploading as a workspace');
  }
  return result[2];
}

/**
 * Returns the file content for a new module.
 */
export function newModuleFileContent() {
  const pythonCode = '\n';
  const exportedBlocks = '[]';
  const blocksContent = '{}';
  return makeFileContent(pythonCode, exportedBlocks, blocksContent);
}

/**
 * Make the file content from the given python code and blocks content.
 */
export function makeFileContent(pythonCode, exportedBlocks, blocksContent) {
  let delimiter = 'BlocksContent';
  while (blocksContent.includes(delimiter) || exportedBlocks.includes(delimiter)) {
    delimiter += '.';
  }
  return (
      '# This file was generated by the Blocks editor.\n\n' +
      pythonCode + '\n\n\n' +
      '"""\n' +
      delimiter + '\n' +
      exportedBlocks + '\n' +
      delimiter + '\n' +
      blocksContent + '\n' +
      delimiter + '\n' +
      '"""\n');
}

/**
 * Extract the blocks content from the given file content.
 */
export function extractBlocksContent(fileContent) {
  // The last line is """.
  const lastChars = '\n"""\n';
  if (!fileContent.endsWith(lastChars) || fileContent.length <= lastChars.length) {
    throw new Error('Unable to extract the blocks content.');
  }
  // The line before that is the delimiter.
  const iEndOfDelimiter = fileContent.length - lastChars.length;
  const iPreviousNewLine = fileContent.lastIndexOf('\n', iEndOfDelimiter - 1);
  if (iPreviousNewLine === -1) {
    throw new Error('Unable to extract the blocks content.');
  }
  const iEndOfBlocksContent = iPreviousNewLine;
  const iStartOfDelimiter = iPreviousNewLine + 1;
  const delimiter = fileContent.substring(iStartOfDelimiter, iEndOfDelimiter);
  // Now, find the previous delimiter.
  const iStartOfPreviousDelimiter = fileContent.lastIndexOf(delimiter, iPreviousNewLine - 1);
  if (iStartOfPreviousDelimiter === -1) {
    throw new Error('Unable to extract the blocks content.');
  }
  // The blocks content is between the two delimiters.
  const iStartOfBlocksContent = iStartOfPreviousDelimiter + delimiter.length + 1;
  return fileContent.substring(iStartOfBlocksContent, iEndOfBlocksContent);
}

/**
 * Extract the exportedBlocks from the given file content.
 */
export function extractExportedBlocks(moduleName, fileContent) {
  // The last line is """.
  const lastChars = '\n"""\n';
  if (!fileContent.endsWith(lastChars) || fileContent.length <= lastChars.length) {
    throw new Error('Unable to extract the exportedBlocks.');
  }
  // The line before that is the delimiter.
  const iEndOfDelimiter = fileContent.length - lastChars.length;
  const iPreviousNewLine = fileContent.lastIndexOf('\n', iEndOfDelimiter - 1);
  if (iPreviousNewLine === -1) {
    throw new Error('Unable to extract the exportedBlocks.');
  }
  const iStartOfDelimiter = iPreviousNewLine + 1;
  const delimiter = fileContent.substring(iStartOfDelimiter, iEndOfDelimiter);
  // Now, find the previous delimiter.
  let iStartOfPreviousDelimiter = fileContent.lastIndexOf(delimiter, iPreviousNewLine - 1);
  if (iStartOfPreviousDelimiter === -1) {
    throw new Error('Unable to extract the exportedBlocks.');
  }
  const iEndOfExportedBlocks = iStartOfPreviousDelimiter - 1;
  // Now, find the previous delimiter before that.
  iStartOfPreviousDelimiter = fileContent.lastIndexOf(delimiter, iStartOfPreviousDelimiter - 1);
  if (iStartOfPreviousDelimiter === -1) {
    throw new Error('Unable to extract the exportedBlocks.');
  }
  // The exportedBlocks content is between the two delimiters.
  const iStartOfExportedBlocks = iStartOfPreviousDelimiter + delimiter.length + 1;
  const exportedBlocksContent = fileContent.substring(iStartOfExportedBlocks, iEndOfExportedBlocks);
  const exportedBlocks = JSON.parse(exportedBlocksContent);
  for (let i = 0; i < exportedBlocks.length; i++) {
    const block = exportedBlocks[i];
    if (block.extraState?.importModule === MODULE_NAME_PLACEHOLDER) {
      block.extraState.importModule = moduleName;
    }
    if (block.fields?.MODULE === MODULE_NAME_PLACEHOLDER) {
      block.fields.MODULE = moduleName;
    }
  }
  return exportedBlocks;
}
